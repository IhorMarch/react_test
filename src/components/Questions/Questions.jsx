import {
  Title,
  Section,
  Answer,

 
} from "./Questions.styled";



export const Questions = () => {


  return (
    <div className='container'>
<Section>
          <Title>1.Для чого потрібний Virtual DOM у React?</Title>
          <Answer>Virtual DOM (віртуальний DOM) - це концепція, яка використовується в бібліотеках та фреймворках, таких як React, для оптимізації процесу відображення змін у веб-додатках. Основна ідея полягає в тому, щоб створювати в пам'яті віртуальне представлення DOM-структури та порівнювати його з реальним DOM для ефективного оновлення інтерфейсу користувача.

          Основні переваги використання Virtual DOM у React:
        

Покращення продуктивності:

Порівняння та оновлення реального DOM може бути витратним з точки зору продуктивності, особливо в великих додатках. Virtual DOM дозволяє мінімізувати кількість маніпуляцій з реальним DOM та оптимізує процес оновлення інтерфейсу.
Зменшення кількості операцій з реальним DOM:

Замість прямого оновлення реального DOM при зміні стану, React спочатку оновлює віртуальний DOM, а потім порівнює його з попереднім станом віртуального DOM (та реальним DOM). Лише необхідні зміни прописуються у реальний DOM, зменшуючи кількість операцій.
Покращена переносимість:

Віртуальний DOM робить аплікації React більш переносимими. Оскільки React може працювати з різними середовищами (включаючи веб, мобільні платформи і навіть серверну сторону), віртуальний DOM дозволяє зберігати спільну модель відображення для всіх платформ.
Спрощення роботи з асинхронним кодом:

Virtual DOM полегшує управління асинхронним кодом, таким як анімації та асинхронні запити до сервера, оскільки можна працювати з віртуальним DOM без прив'язки до реального DOM.
Зручна робота з React-компонентами:

Віртуальний DOM забезпечує зручний інтерфейс для роботи з React-компонентами, використовуючи JSX, що робить код більш читабельним і зрозумілим.
Враховуючи ці переваги, використання Virtual DOM робить React ефективним та зручним інструментом для розробки веб-додатків.</Answer>

          <Title>2.Яка різниця між virtual DOM та shadow DOM?</Title>     
          <Answer>Virtual DOM та Shadow DOM - це дві різні концепції, які використовуються веб-розробкою для поліпшення управління та ізоляції DOM-структур. Однак вони розроблені для різних цілей і використовуються в різних сценаріях.

Virtual DOM:

Ціль: Оптимізація оновлення та відображення DOM для покращення продуктивності.
Що це:
Virtual DOM - це механізм оптимізації роботи з реальним DOM в бібліотеках та фреймворках, таких як React. Він полягає в створенні в пам'яті віртуального представлення DOM та порівнянні його з реальним DOM для ефективного оновлення інтерфейсу.
Застосування:
Оптимізація взаємодії з реальним DOM, зменшення кількості операцій з ним, полегшення оновлення стану та відображення.
Shadow DOM:

Ціль: Забезпечення ізоляції та управління структурою DOM для створення компонентів, які ізольовані від зовнішнього коду.
Що це:
Shadow DOM - це технологія, яка дозволяє ізолювати та приховувати внутрішню структуру компонентів від зовнішнього коду. Кожен Shadow DOM володіє своїм власним замкнутим скоупом стилів і DOM-елементів.
Застосування:
Створення ізольованих компонентів, які можуть містити свою внутрішню структуру та стилі, незалежно від зовнішнього коду. Часто використовується веб-компонентами.
Важливо відзначити, що ці дві технології можуть використовуватися разом. Наприклад, бібліотека React може використовувати Virtual DOM для оптимізації відображення змін, а веб-компоненти, створені з використанням Shadow DOM, можуть забезпечувати ізоляцію та структурну інкапсуляцію.</Answer>
    
          <Title>3.Яка різниця між state та props?</Title>
          <Answer>state та props - це два основних концепти в React, які використовуються для управління даними та передачі інформації між компонентами. Однак їх призначення та способи використання відзначаються.

State:

Призначення:
state використовується для управління внутрішнім станом компонента. Це дані, які можуть змінюватися протягом життєвого циклу компонента.
Ініціалізація:
state ініціалізується у конструкторі компонента або за допомогою нового API useState у функціональних компонентах.
Зміна стану:
Для зміни state використовують метод setState(), який після встановлення нового стану переоновлює компонент та викликає його метод render().
Локальний для компонента:
state є локальним для компонента, і не може передаватися вниз по ієрархії компонентів без використання props.
Props:

Призначення:
props (властивості) використовуються для передачі даних в компонент ззовні. Вони вважаються "тим, що передається" компоненту.
Ініціалізація:
props передаються компоненту як атрибути в JSX або вказуються при виклику компонента внутрішньої частини іншого компонента.
Незмінність:
props є незмінними (immutable). Компонент не може змінювати свої власні props.
Глобальний для дерева компонентів:
props можна передавати вниз по дереву компонентів, дозволяючи даним потрапляти в дочірні компоненти.
Підсумовуючи, state використовується для управління внутрішнім станом компонента, тоді як props використовується для передачі даних в компоненти та є незмінними у своїй природі. Обидва концепти є фундаментальними для розробки на React і грають ключову роль в створенні динамічних та переиспользуемых компонентів.</Answer>
           <Title>4.Яка різниця між класовим та функціональним компонентом?</Title>
          <Answer>Стан (State):

Класові компоненти:
Мають можливість використовувати локальний стан (local state) і методи життєвого циклу.
Функціональні компоненти:
Зазвичай використовуються без власного стану. З React 16.8 і введенням хуків (наприклад, useState), функціональні компоненти можуть управляти станом та використовувати інші функціональності класових компонентів.
Життєвий цикл (Lifecycle):

Класові компоненти:
Мають повний набір методів життєвого циклу, таких як componentDidMount, componentDidUpdate, і т.д.
Функціональні компоненти:
Використовують хуки для роботи з життєвим циклом, таких як useEffect для виконання певних дій після монтажу компонента або після кожного оновлення.
Читання та передача пропсів (Props):

Класові компоненти:
Користуються this.props для отримання значень пропсів.
Функціональні компоненти:
Отримують пропси безпосередньо як параметри функції.
Розширення функціональності:

Класові компоненти:
Мають можливість використовувати більше функціональності, такої як стан, методи життєвого циклу і контекст.
Функціональні компоненти:
Зазвичай є більш простими і експресивними. З хуками, такими як useState і useEffect, вони також отримали багато функціональності, яку раніше надавали тільки класові компоненти.</Answer>
           <Title>5.Які методи життєвого циклу є в React?</Title>
          <Answer>В React існує низка методів життєвого циклу для класових компонентів, які дозволяють вам виконувати різні дії на різних етапах життєвого циклу компонента. Ось основні методи життєвого циклу в React:

Mounting (Монтаж):

constructor(): Викликається при створенні екземпляру компонента.
static getDerivedStateFromProps(): Викликається перед рендерингом і при кожному оновленні. Використовується для оновлення стану на основі нових властивостей.
render(): Відображає компонент. Це обов'язковий метод.
componentDidMount(): Викликається після рендерингу компонента. Використовується для виконання дій після того, як компонент був доданий до DOM.
Updating (Оновлення):

static getDerivedStateFromProps(): Знову викликається при оновленні. Використовується для оновлення стану на основі нових властивостей.
shouldComponentUpdate(): Викликається перед рендерингом при оновленні. Визначає, чи потрібно виконувати оновлення компонента.
render(): Повторно відображає компонент.
getSnapshotBeforeUpdate(): Викликається перед тим, як оновлений вміст був відображений на екрані. Використовується для отримання даних перед оновленням.
componentDidUpdate(): Викликається після завершення оновлення. Використовується для виконання дій після оновлення компонента.
Unmounting (Видалення):

componentWillUnmount(): Викликається перед тим, як компонент буде видалений з DOM. Використовується для виконання необхідних очисних операцій.
Error Handling (Обробка Помилок):

static getDerivedStateFromError(): Викликається при виникненні помилки при рендерингу дочірнього компонента. Використовується для оновлення стану на основі помилки.
componentDidCatch(): Викликається після того, як виникла помилка при рендерингу дочірнього компонента. Використовується для логування помилок.
Ці методи дозволяють вам керувати поведінкою компонентів на різних етапах їхнього життєвого циклу. У реактивному програмуванні також існують хуки, такі як useEffect в функціональних компонентах, які забезпечують подібні можливості для роботи з життєвим циклом.</Answer>
           <Title>6.Як оновити state у класовому компоненті?</Title>
        <Answer>Оновлення стану у класовому компоненті в React виконується за допомогою методу setState().
          Цей метод приймає аргумент у вигляді об'єкта, який містить новий стан, або приймає функцію, яка отримує поточний стан і властивості та повертає новий стан.
Важливо вказати, що setState() може бути асинхронним, і React може групувати кілька викликів setState() для оптимізації продуктивності. Якщо новий стан залежить від поточного стану, краще використовувати функцію у setState(), оскільки вона гарантує правильне оновлення стану.

        </Answer>
           <Title>7.Чому setState асинхронна функція?</Title>
          <Answer>setState у React є асинхронною функцією з кількома причинами:

Оптимізація продуктивності:

React може групувати декілька викликів setState та обробляти їх разом, щоб уникнути непотрібних оновлень і оптимізувати продуктивність. Це може бути особливо корисно при викликах setState в одному циклі життєвого циклу чи при обробці подій.
Відновлення поточного стану:

React може визначити, що вказані зміни стану базуються на поточному стані компонента. Якщо викликати setState синхронно, це може привести до проблем, оскільки React може ще не оновити внутрішній стан компонента.
Життєвий цикл та рендеринг:

Асинхронний підхід setState дозволяє React планувати оновлення стану таким чином, щоб вони відбувалися відповідно до життєвого циклу та рендерингу. Це допомагає уникнути непотрібних перерендерів та може підвищити продуктивність додатка.
Основна концепція полягає в тому, що виклик setState не негайно міняє стан, а планує його оновлення. Це забезпечує більш прогнозоване та ефективне оновлення стану у React-додатках.</Answer>
           <Title>8.Що потрібно зробити, щоб компонент оновився?</Title>
          <Answer>У React, оновлення компоненту може відбутися автоматично, коли стан (state) або властивості (props) змінюються. Однак є кілька способів вручну спричинити оновлення компонента.

setState для оновлення стану:
Викликайте метод setState для зміни стану компонента. Це автоматично спричинить перерендеринг компонента. 
У React, оновлення компоненту може відбутися автоматично, коли стан (state) або властивості (props) змінюються. Однак є кілька способів вручну спричинити оновлення компонента.

setState для оновлення стану:
Викликайте метод setState для зміни стану компонента. Це автоматично спричинить перерендеринг компонента.


forceUpdate метод:
          Виклик методу forceUpdate також може вручну примусити компонент оновити свій стан та відобразити зміни. Звертайте увагу, що використання
          forceUpdate вважається не найкращою практикою і варто уникати його, якщо це не абсолютно необхідно.
          Використання ключа (key) при відображенні:
          Зміна ключа компонента при його відображенні може призвести до його перерендерингу.
          Хуки в функціональних компонентах:
У функціональних компонентах використання хуків, таких як useState та useEffect, дозволяє автоматично керувати оновленням компонента при зміні стану або властивостей.
        </Answer>
        
        <Title>9.Як запобігти зайвому оновленню компонента?</Title>
        <Answer>Використовуйте shouldComponentUpdate у класових компонентах:
Ви можете використовувати метод shouldComponentUpdate для визначення, чи потрібно виконувати перерендеринг компонента при зміні стану чи властивостей. Повернення false зупиняє оновлення.Використовуйте PureComponent:
PureComponent є класом, який вже має вбудований метод shouldComponentUpdate, який автоматично порівнює всі властивості та стан. Використовуйте PureComponent замість Component, якщо ваш компонент залежить тільки від властивостей та стану.Використовуйте React.memo для функціональних компонентів:
Використовуйте React.memo для автоматичного порівняння властивостей функціонального компонента та уникнення зайвих рендерів.Передавайте функції як властивості замість вбудованих методів:
При передачі функцій як властивостей компоненту, уникайте визначення їх у тілі класу. Кожен раз, коли ви передаєте функцію як властивість, створюється нова функція, що може спричинити зайві оновлення. Замість цього використовуйте стрілкові функції або методи, визначені за межами рендерингу.
        
        
        </Answer>
           <Title>10.Яка особливість PureComponent?
</Title>
          <Answer>PureComponent є класом у React, який представляє собою спеціальний випадок звичайного класового компонента (Component). Основна особливість PureComponent полягає в автоматичному виклику методу shouldComponentUpdate для порівняння нових та поточних властивостей та стану. Це дозволяє уникнути зайвого оновлення компонента, якщо властивості та стан не змінились.

Основні риси та особливості PureComponent:

Автоматичне порівняння властивостей та стану:

PureComponent автоматично викликає shouldComponentUpdate і порівнює всі властивості (props) та стан (state) з попередніми значеннями. Якщо вони рівні, то оновлення компонента не відбудеться.
Автоматична оптимізація для простих випадків:

Якщо ваш компонент не залежить від внутрішнього стану, а лише від властивостей, PureComponent може автоматично оптимізувати оновлення, щоб уникнути зайвих рендерів.
Не викликає render при непотрібних оновленнях:

Якщо shouldComponentUpdate повертає false, метод render не буде викликаний, що зменшить навантаження на DOM та покращить продуктивність.
Рекомендації щодо використання:

Використовуйте PureComponent тільки тоді, коли ви впевнені, що порівнювані властивості та стан можна швидко порівняти (наприклад, примітивні значення або прості об'єкти/масиви).
Не викликає shouldComponentUpdate для глибоких порівнянь:

Якщо властивість чи стан містять вкладені об'єкти або масиви, PureComponent не проводить глибоке порівняння. Таким чином, якщо ви змінюєте вкладений об'єкт чи масив, оновлення може відбутись, навіть якщо вони мають однакову структуру.
Щоб використовувати PureComponent, ваш клас повинен успадковуватися від PureComponent замість звичайного Component:</Answer>
           <Title>11.Для чого потрібні key?
</Title>
          <Answer>key - це атрибут, який використовується в React при рендері списків елементів. Кожен елемент в списку повинен мати унікальний key. Основна причина використання ключів - це покращення ефективності та ефективності вирішення проблем, пов'язаних із перерендерюванням списків.

Основні причини використання ключів в React:

Ефективне перерендерювання списків:

При зміні порядку, кількості або додаванні/видаленні елементів в списку React використовує ключі для ефективного перерендерювання тільки тих елементів, які зазнали змін. Це дозволяє уникнути повного перерендерювання всього списку, що поліпшує продуктивність.
Унікальність елементів:

Ключі допомагають React відслідковувати ідентичність кожного елемента в списку. Це важливо для правильного визначення змін та вирішення проблем із збереженням стану компонентів.
Допомога зі збереженням стану компонентів:

Якщо ви маєте компоненти в списку, які зберігають свій власний стан, ключі допомагають React правильно ідентифікувати ці компоненти при перерендерюванні і зберегти їх стан.</Answer>
           <Title>12.Для чого потрібний компонент Fragment?
</Title>
          <Answer>Fragment - це спеціальний компонент в React, який дозволяє групувати дочірні елементи без створення зайвого DOM-елементу. В React, компонент Fragment використовується, коли вам потрібно повернути більше одного елемента з компонента, і ви не хочете, щоб ці елементи об'єднувалися в обгортку DOM.

Основні причини використання Fragment:

Уникнення зайвого DOM-елемента:

При поверненні декількох елементів без використання Fragment, вони автоматично обгортаються в реальний DOM-елемент (зазвичай div), навіть якщо вам це не потрібно. Використання Fragment дозволяє уникнути створення зайвого DOM-елемента, що може бути важливим для стилізації та структури коду.
Повернення декількох елементів без обгортки:

Fragment дозволяє вам повертати декілька елементів без необхідності обгортки їх в зайвий контейнер. Це дуже зручно, коли ви хочете повернути список елементів чи іншу групу елементів.</Answer>
           <Title>13.Для чого потрібні портали?</Title>
          <Answer>
Портали (Portals) в React дозволяють вам рендерити дочірні компоненти в DOM-елемент, який знаходиться за межами структури компонента, що рендерить їх. Основні причини використання порталів включають:

Рендеринг в інший DOM-контейнер:

За допомогою порталів ви можете рендерити компоненти в будь-який інший DOM-контейнер, який існує в вашій веб-сторінці. Це дозволяє вам створювати компоненти, які виводяться за межами основного дерева DOM вашого додатка.
Рендеринг в контейнери поверх інших елементів:

Портали дозволяють вам вставляти компоненти поверх інших елементів в DOM. Наприклад, ви можете створити модальне вікно, яке буде виводитися поверх усього іншого в DOM-структурі.
Рендеринг в загальності несподівані місця:

За допомогою порталів ви можете рендерити компоненти в місця, які ви не очікували. Це може бути корисним для створення розділених ділянок UI або рендерингу компонентів у визначених областях сторінки.
Уникнення проблем з контекстом та стилями:

Використання порталів дозволяє уникнути проблем з контекстом та стилями, оскільки рендеринг в інший контейнер не впливає на контекст і стилі основного компонента.</Answer>
           <Title>14.Що таке refs?
</Title>
          <Answer>ref в React - це спеціальний атрибут, який дозволяє вам отримати прямий доступ до DOM-елемента чи екземпляра компонента в коді React. Використання ref може бути корисним в різних випадках, таких як управління фокусом, анімації, імперативна маніпуляція DOM та інше.

Є два способи використання ref в React:

Створення ref за допомогою React.createRef():

Використовується в класових компонентах. Callback-функція для ref:

Використовується в функціональних компонентах або коли ви працюєте з createRef() в функціональних компонентах.Основні випадки використання ref:

Отримання прямого доступу до DOM-елемента: Ви можете використовувати ref для отримання прямого доступу до DOM-елемента та виконання імперативних операцій, таких як фокусування чи вибір тексту.

Взаємодія з компонентами:

Коли вам потрібно взаємодіяти з методами компонентів, використовуючи класові компоненти. Наприклад, виклик методів певного компонента після виконання певних умов або подій.
Використання в бібліотеках для імперативного контролю:

Ви можете використовувати ref в бібліотеках або пакетах, які вимагають імперативного контролю над елементами.
Однак, використання ref повинно бути обмеженим, і в більшості випадків краще використовувати управління станом та подіями для взаємодії з компонентами в React.</Answer>
           <Title>15.Що таке context?
</Title>
          <Answer>В React, context - це механізм, який дозволяє передавати дані через дерево компонентів без явного передання пропсів через кожен рівень компонентів. Використання context зручне у випадках, коли багато компонентів потребують однакових даних, таких як тема оформлення, аутентифікація користувача або інші глобальні налаштування.

context складається з двох частин: провайдера (Context.Provider) та споживачів (Context.Consumer або використання useContext хука в функціональних компонентах).

Основні поняття, пов'язані з context:

Створення контексту:

Спершу необхідно створити контекст за допомогою функції React.createContext().Постачання значень (Provider):

Використовуйте MyContext.Provider для обгортання частини дерева компонентів, яка повинна мати доступ до значень context.Споживання значень (Consumer або useContext):

Використовуйте MyContext.Consumer або useContext(MyContext) для отримання значень context в дочірніх компонентах. Або використання useContext хука в функціональних компонентах.context дозволяє передавати дані глибоко вниз по дереву компонентів без необхідності передачі пропсів через кожен рівень компонентів. Однак слід використовувати його обережно і уникати зловживання, оскільки це може зробити код менш зрозумілим і важко підтримуваним. В більшості випадків краще використовувати передачу пропсів або стану.</Answer>

           <Title>16.Для чого потрібні render props?
</Title>
          <Answer>Render props (рендер-властивості) - це підхід в React, коли компонент отримує функцію в якості пропса, яку можна використовувати для визначення вмісту компонента. Цей підхід надає більшу гнучкість та переиспользуемость компонентів.

Основні причини використання render props:

Гнучкість компонентів:

Render props дозволяють вам передавати в компонент функцію, яка визначає, як його вміст повинен виглядати. Це дозволяє створювати більш гнучкі та параметризовані компоненти.
Переиспользование логіки:

Використання render props дозволяє легко переиспользовати логіку між компонентами, так як ви можете передавати різні функції для рендерінгу вмісту.
Вищий рівень абстракції:

Застосування render props дозволяє створювати компоненти, які не повинні знаходити свій вміст впереджу.</Answer>
           <Title>17.Що таке HOCs?
</Title>
          <Answer>HOCs або "Higher-Order Components" (компоненти вищого порядку) - це концепція у React, яка дозволяє використовувати та реюзати логіку в компонентах. HOC - це функція, яка приймає компонент і повертає новий компонент з додатковою функціональністю або зміненою логікою.

Основні ідеї HOC:

Прийом компонента:

HOC приймає компонент як аргумент.
Повернення нового компонента:

HOC повертає новий компонент, який може мати додаткову функціональність або змінену логіку.
Переіменування пропсів:

HOC може додавати, змінювати або видаляти пропси для передачі компоненту.
Логіка компонента вищого порядку:

HOC може виконувати деяку логіку перед передачею її до оригінального компонента.</Answer>
           <Title>18.Як реалізувати компонент запобіжника (Error Boundary)?</Title>
          <Answer> Компонент запобіжника (Error Boundary) - це спеціальний тип компонента в React, який може захоплювати та обробляти помилки, які виникають у внутрішніх компонентах під час їхнього рендерингу, а також при оновленні componentDidCatch інтерфейсу. Використовуючи компоненти запобіжника, можна контролювати та відображати альтернативний інтерфейс при виникненні помилки, уникнути відображення білого екрана або викидання помилок.

Щоб створити компонент запобіжника, вам потрібно визначити методи componentDidCatch та render. componentDidCatch викликається, коли в одному з дочірніх компонентів виникає помилка.
</Answer>
           <Title>19.Які можливості надають хуки?</Title>
          <Answer>Хуки (Hooks) - це новий механізм у React, який дозволяє використовувати стан та інші функціональності React в компонентах, написаних як функції. Вони надають можливості для використання стану, ефектів, контексту та інших функціональностей в функціональних компонентах. Основні хуки в React включають:

useState:

Дозволяє створювати та використовувати стан в функціональних компонентах. useEffect:

Дозволяє виконувати ефекти (такі як відстеження змін, асинхронні запити, підписки) в функціональних компонентах.seContext:

Дозволяє використовувати значення контексту в функціональних компонентах.
useReducer:

Дозволяє використовувати Reducer для управління станом в функціональних компонентах. useCallback:

Дозволяє оптимізувати збереження функцій-зворотніх викликів для уникнення їхнього перестворення при оновленні компонента.</Answer>
           <Title>20.Які правила використання хуків?
</Title>
        <Answer>Використовуйте хуки тільки в функціональних компонентах та кастомних хуках:

Хуки призначені для використання в функціональних компонентах та кастомних хуках, а не в класових компонентах чи звичайних функціях.
Використовуйте хуки тільки на верхньому рівні функціонального компонента:

Не викликайте хуки в циклах, умовних конструкціях або вкладених функціях. Виклик хуку повинен завжди бути на верхньому рівні компонента.икористовуйте хуки завжди в одному й тому ж порядку:

Якщо ви використовуєте декілька хуків в компоненті, завжди викликайте їх в одному й тому ж порядку. Це дозволяє React відслідковувати стан і обновлення компонента.Використовуйте хуки лише в тілах функціональних компонентів або в кастомних хуках:

Хуки слід викликати лише в тілах функціональних компонентів або в тілах кастомних хуків (функцій, які починаються на "use").Використовуйте хуки відповідно до їхніх правил користування:

Кожен хук має власні правила користування, які слід дотримуватися. Наприклад, useEffect повинен використовуватися для виконання ефектів, а useState - для встановлення стану.</Answer>
         <Title>21.Для чого потрібний useEffect?
</Title>
        <Answer>
Хук useEffect в React використовується для виконання побічних ефектів у функціональних компонентах. Побічні ефекти включають в себе дії, які необхідно виконати після рендерингу компонента, такі як відправлення запитів на сервер, підписки на дані, зміни глобального стану, тощо. Використання useEffect дозволяє розмістити ці дії в компоненті та забезпечити, щоб вони викликалися в правильний час.

Основні моменти, для яких потрібно використовувати useEffect:

Завантаження даних:

Викликати API запити або завантажити дані з сервера після того, як компонент був відображений на екрані.Підписка на дані або події:

Встановити підписку на зміни або події під час монтажу компонента та відписатися від них під час розмонтажу.Оптимізація та відсіювання повторних рендерів:

Використовується для оптимізації та відсіювання повторних рендерів, якщо це необхідно.Виклик коду після кожного рендерингу:

Викликає код після кожного рендерингу компонента, незалежно від того, чи відбулися зміни чи ні.useEffect дозволяє керувати побічними ефектами в компонентах та забезпечити правильний порядок викликів важливих функцій під час життєвого циклу компонента.</Answer>
         <Title>22.Чим відрізняється useEffect від useLayoutEffect?
</Title>
        <Answer>useEffect і useLayoutEffect є двома хуками в React, які дозволяють виконувати побічні ефекти в функціональних компонентах. Однак є певні відмінності в тому, коли вони викликаються під час життєвого циклу компонента.

Основна відмінність між ними полягає в часі їхнього виклику:

useEffect:

Викликається після завершення фази оновлення та фактичного відображення змін на екрані. Викликається після рендерингу і не блокує браузер у процесі оновлення і відображення DOM.useLayoutEffect:

Викликається перед тим, як браузер оновить екран. Зазвичай використовується там, де важливо виконати код після рендерингу, але до відображення змін. Завдяки цьому можна впливати на розміри та положення DOM-елементів перед їхнім відображенням.Зазвичай використовують useEffect, оскільки в більшості випадків це непомітно для користувача, і використання useLayoutEffect може призвести до затримок в роботі і відобразити плаваюче відображення. Однак useLayoutEffect може бути корисним у випадках, коли важливо впливати на макет до його відображення.</Answer>
         <Title>23.Що таке лінива ініціалізація стану в useState та useReducer?
</Title>
        <Answer>Лінива ініціалізація стану в контексті useState і useReducer в React означає можливість передачі функції як аргументу для ініціалізації стану замість простого значення. Ця функція буде викликана тільки під час початкового рендерингу, і результат виклику буде використовуватися як початковий стан компонента.
          У випадку useState, передача функції встановлює ліниву ініціалізацію. Це особливо корисно, якщо ініціалізація стану вимагає виконання дорогих обчислень або взаємодії з іншими частинами коду.
        У випадку useReducer, третій параметр в функцію useReducer вказує на ліниву ініціалізацію стану. Це дозволяє використовувати функцію для ініціалізації стану під час початкового рендерингу.

Лінива ініціалізація корисна в ситуаціях, де ви хочете втримати важкі обчислення або операції, що можуть займати багато часу, від рендерингу, який відбувається під час створення компонента.</Answer>
         <Title>24.Чим useRef відрізняється від createRef?
</Title>
        <Answer>useRef та createRef обидва використовуються для отримання посилань на DOM-елементи або для збереження мутабельних значень в об'єктах ref. Однак вони мають деякі важливі відмінності:

Використання в функціональних компонентах:

          useRef призначений для використання в функціональних компонентах, оскільки він інтегрований із системою хуків.createRef використовується в класових компонентах.
        
useRef та createRef обидва використовуються для отримання посилань на DOM-елементи або для збереження мутабельних значень в об'єктах ref. Однак вони мають деякі важливі відмінності:



createRef використовується в класових компонентах.

Поведінка під час оновлення:

useRef повертає той самий об'єкт ref при кожному рендерингу, тому він не спричиняє додаткового рендерингу при оновленні компонента.

createRef, у класовому компоненті, кожного разу, коли компонент рендериться, створюється новий об'єкт ref. Це може призводити до додаткових рендерів при оновленні.

Маніпуляція значенням:

Об'єкт ref, який повертається useRef, має властивість current, що є мутабельним об'єктом. Ви можете змінювати його значення без спричинення оновлення компонента.

Значення, повернене createRef, також є мутабельним об'єктом, і ви можете змінювати його значення. Однак при кожному оновленні компонента новий об'єкт ref створюється, тому збереження значення між оновленнями може бути складніше.

Загалом, useRef є більш зручним для використання в функціональних компонентах, особливо при роботі з хуками та ефектами, оскільки він інтегрований із системою хуків React. В той час як createRef призначений для класових компонентів.
        
        
        </Answer>
         <Title>25.Для чого потрібні useMemo та useCallback?
</Title>
        <Answer>useMemo та useCallback - це два хуки в React, які використовуються для оптимізації производительності, зменшення зайвих обчислень та уникнення непотрібного рендерингу компонентів. Однак вони мають різні застосування та спрямовані на різні випадки використання.

useMemo:

Використовується для кешування результатів обчислень, тобто мемоізації значення під час рендерингу компонентів.Використовується, коли потрібно уникати повторних обчислень у випадку, коли значення може змінюватися, але ви хочете, щоб обчислення виконувалися тільки при зміні залежностей.
useCallback:

Використовується для створення кешованих версій callback-функцій, що дозволяє уникнути створення нових функцій при кожному рендерингу.Використовується, коли потрібно уникати виклику нових функцій при передачі callback-функцій у властивості дочірніх компонентів. Забезпечує стабільність посилань на callback-функції між рендерингами.
Загалом, useMemo використовується для оптимізації обчислень, тоді як useCallback - для оптимізації callback-функцій, зменшення їхнього створення під час рендерингу. Вони допомагають забезпечити більш ефективне використання ресурсів та уникнення непотрібного перерахування.</Answer>
         <Title>26.Для чого потрібний redux?
</Title>
        <Answer>Redux - це бібліотека для керування станом додатка в JavaScript-додатках, особливо в інтерфейсах користувача з великою кількістю стану. Основна ідея Redux полягає в тому, щоб утримувати весь стан додатка в одному місці (зберігання стану) і контролювати зміни цього стану за допомогою чистих функцій, відомих як "reducers". Основні принципи та вигоди Redux:

Простота та прозорість стану:

Весь стан додатка зберігається в одному об'єкті (зазвичай називається "store"). Це робить стан прозорим і полегшує відладку та розуміння роботи додатка.
Постійність (Immutability):

Стан недоступний для прямого змінення. Замість цього, для зміни стану використовуються чисті функції (reducers), які повертають новий стан на основі попереднього. Це допомагає уникати непередбачуваних побічних ефектів і полегшує відстеження змін.
Однозначність та передбачуваність:

Всі зміни стану відбуваються шляхом виклику чистих функцій (reducers), що робить їх передбачуваними і легко відстежуваними.
Централізований стан:

Стан додатка є централізованим і доступним з будь-якого місця. Це дозволяє компонентам спілкуватися між собою через цей стан, зменшуючи необхідність передачі даних через багато рівнів вкладеності.
Легка інтеграція з React:

Redux легко інтегрується з бібліотекою React, що дозволяє легко управляти станом компонентів та робити їхню роботу більш передбачуваною та швидкою.
Додаткові можливості:

Redux надає різні розширення та інструменти для відстеження змін стану, логування, асинхронних дій (через middleware), інтеграції з DevTools та інше.
Redux особливо корисний в додатках зі складним станом, де важливо добре визначити та контролювати зміни стану. Його застосовують у великих веб-додатках, а також у мобільних та інших типах додатків, де стан може бути складним та розподіленим.</Answer>
         <Title>27.Поясніть redux data flow
</Title>
        <Answer> Redux використовує однонапрямлений потік даних, який допомагає управляти станом додатка в передбачуваний та однозначний спосіб. Потік даних в Redux можна описати таким чином:

Дії (Actions):

Дії є об'єктами, що містять інформацію про події, які відбуваються у додатку. Вони є єдиним джерелом інформації про те, що трапляється.
Dispatch (Відправка дій):

Дії відправляються в Redux за допомогою функції dispatch. Коли ви викликаєте dispatch(action), ви сповіщаєте Redux про те, що щось сталося.
Редуктори (Reducers):

Редуктори - це чисті функції, які приймають поточний стан та дію, і повертають новий стан. Кожен редуктор відповідає за певну частину стану додатка.
Сховище (Store):

Сховище - це об'єкт, який об'єднує всі редуктори та утримує поточний стан додатка. Ви створюєте сховище, передаючи йому кореневий редуктор.
Підписники (Subscribers):

Підписники - це функції, які викликаються кожного разу, коли стан додатка змінюється. Коли стан оновлюється, всі підписники сповіщаються про зміни.
Цей процес називається "однокращим" або "однонапрямленим" потоком даних через Redux. Давайте розглянемо кроки більш детально:

Відправка дії:

Ваш компонент взаємодіє з користувачем, і відбувається якась подія (наприклад, клік на кнопці).
Ви викликаєте dispatch і відправляєте дію Redux.
Виклик редукторів:

Кожен редуктор, який ви маєте в сховищі, отримує цю дію.
Редуктори вирішують, як повинен бути змінений стан на основі отриманої дії.
Оновлення стану:

Сховище об'єднує результати всіх редукторів в новий стан.
Якщо є зміни в стані, то сховище викликає всі підписники.
Виклик підписників:

Підписники (компоненти) отримують повідомлення про оновлення та оновлюють свій стан або викликають перерендеринг.
Цей цикл дозволяє зберігати та оновлювати стан додатка в один і той самий спосіб, що полегшує його розуміння та відладку.
</Answer>
         <Title>28.Що таке redux middleware?</Title>
        <Answer>
Middleware в Redux - це шар, який розширює функціональність Redux між моментом відправлення дії та моментом, коли дія доходить до редуктора. Middleware може втручатися в потік даних та виконувати додаткові дії, такі як логування, асинхронні запити, зміни дій тощо.

У Redux, middleware - це функція, яка отримує доступ до стандартного об'єкта store, інтерфейсу dispatch та getState. Middleware також може передавати дію далі, змінювати її або навіть скасовувати.

Основні рекомендації по створенню middleware виглядають так:

Додавання Middleware:

Middleware додається за допомогою функції applyMiddleware під час створення сховища Redux.Структура Middleware:

Middleware - це функція, яка повертає іншу функцію, яка приймає next (функція далі по ланцюжку middleware) та повертає функцію, яка отримує action.Middleware використовується для реалізації різних завдань, таких як логування, обробка асинхронних запитів, зміна дій тощо. Розширення функціональності за допомогою middleware дозволяє створювати більш складні та адаптовані до потреб додатки в Redux.</Answer>

        <Title>29.Де потрібно робити side effects в redux?</Title>
          <Answer>
Side effects (ефекти) в Redux, такі як асинхронні операції, мережеві запити, робота з локальним сховищем чи інші нечисті функції, зазвичай обробляються в middleware, іншими словами - в середньому шарі між відправленням дії та її досягненням редуктора.

Redux має стандартний middleware для обробки таких side effects, як, наприклад, redux-thunk для роботи з асинхронним кодом. Цей middleware дозволяє вам диспетчеризувати функції замість об'єктів дій, і ці функції можуть містити логіку з асинхронним кодом та іншими side effects.</Answer>
         <Title>30.Що таке next() функція в redux middleware?
</Title>
        <Answer>next() - це функція, яка передає управління наступному middleware в ланцюжку або, якщо middleware - останнє в ланцюжку, то до редуктора. У контексті Redux middleware, next - це параметр функції, яку ви отримуєте в середовищі middleware.
          Важливо викликати next(action) у вашому middleware, інакше ланцюжок middleware буде перерваний, і подальші middleware та редуктор не будуть викликані.
        </Answer>
         <Title>31.Для чого потрібні redux селектори?
</Title>
        <Answer>Redux селектори - це функції, які призначені для вибору та обчислення значень зі стану Redux. Вони використовуються для вибору конкретних частин стану та виконання розрахунків або обробки даних перед їхнім використанням в компонентах React чи в іншому коді.

Основні причини використання селекторів включають:

Вибір частини стану:

Селектори дозволяють вам отримувати доступ до конкретних частин стану без прямого звертання до об'єкта стану. Це полегшує роботу зі станом і забезпечує однорідний інтерфейс доступу до даних.
Розрахунки та обробка даних:

Селектори можуть включати логіку розрахунків та обробки даних. Вони дозволяють вам трансформувати дані, обчислювати похідні значення або виконувати будь-які інші дії над даними перед їхнім використанням.
Оптимізація рендерингу:

Використання селекторів допомагає уникнути непотрібних рендерів компонентів. Селектори можуть повертати тільки ті значення, які змінилися, тим самим сприяючи уникненню непотрібних перерендерів та поліпшенню продуктивності.
Підтримка рефакторингу:

Використання селекторів робить код більш модульним і легше піддаватися рефакторингу. Ви можете змінювати логіку селекторів, не змінюючи компоненти, що використовують ці селектори.
Ізоляція компонентів від структури стану:

Селектори дозволяють ізолювати компоненти від структури стану. Компонентам не потрібно знати про внутрішню структуру стану або деякі деталі реалізації. Вони просто викликають селектор, який надає необхідні дані.
Підвищення читабельності коду:

Використання селекторів полегшує розуміння коду та його читабельність. Вони дозволяють організовувати та структурувати код, роблячи його більш зрозумілим.
Одним із популярних пакетів для створення селекторів у Redux є бібліотека Reselect. З її допомогою можна легко створювати мемоізовані селектори для оптимізації вибору та обчислення даних.</Answer>
         <Title>32.Чим відрізняється action від action creator?
</Title>
        <Answer></Answer>
         <Title></Title>
        <Answer>Action creator - це функція, яка створює та повертає action (дію). Вона є частиною інтерфейсу взаємодії з Redux, і використовується для уникнення написання action об'єктів прямо в коді.
          Action - це об'єкт, який передає інформацію про подію, що відбувається в додатку. Його обов'язковим полем є type, яке вказує на тип події. Інші поля, такі як payload, можуть містити додаткову інформацію.
          Основна різниця між action та action creator полягає в тому, що action creator - це функція, яка генерує та повертає action об'єкт, тоді як action - це сам action об'єкт, який містить інформацію про подію.

Використання action creators дозволяє зробити код більш структурованим, дозволяє передавати параметри, та спрощує зміну формату action у майбутньому. Усі action creators, які повертають action об'єкти, можуть бути викликані в середині функцій або в компонентах для диспетчеризації подій в Redux.
          
        </Answer>


     </Section>
      </div>
  );
};