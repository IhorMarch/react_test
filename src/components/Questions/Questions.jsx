import {
  Title,
  Section,
  Answer,

 
} from "./Questions.styled";



export const Questions = () => {


  return (
    <div className='container'>
<Section>
          <Title>1.Для чого потрібний Virtual DOM у React?</Title>
          <Answer>Virtual DOM (віртуальний DOM) - це концепція, яка використовується в бібліотеках та фреймворках, таких як React, для оптимізації процесу відображення змін у веб-додатках. Основна ідея полягає в тому, щоб створювати в пам'яті віртуальне представлення DOM-структури та порівнювати його з реальним DOM для ефективного оновлення інтерфейсу користувача.

          Основні переваги використання Virtual DOM у React:
        

Покращення продуктивності:

Порівняння та оновлення реального DOM може бути витратним з точки зору продуктивності, особливо в великих додатках. Virtual DOM дозволяє мінімізувати кількість маніпуляцій з реальним DOM та оптимізує процес оновлення інтерфейсу.
Зменшення кількості операцій з реальним DOM:

Замість прямого оновлення реального DOM при зміні стану, React спочатку оновлює віртуальний DOM, а потім порівнює його з попереднім станом віртуального DOM (та реальним DOM). Лише необхідні зміни прописуються у реальний DOM, зменшуючи кількість операцій.
Покращена переносимість:

Віртуальний DOM робить аплікації React більш переносимими. Оскільки React може працювати з різними середовищами (включаючи веб, мобільні платформи і навіть серверну сторону), віртуальний DOM дозволяє зберігати спільну модель відображення для всіх платформ.
Спрощення роботи з асинхронним кодом:

Virtual DOM полегшує управління асинхронним кодом, таким як анімації та асинхронні запити до сервера, оскільки можна працювати з віртуальним DOM без прив'язки до реального DOM.
Зручна робота з React-компонентами:

Віртуальний DOM забезпечує зручний інтерфейс для роботи з React-компонентами, використовуючи JSX, що робить код більш читабельним і зрозумілим.
Враховуючи ці переваги, використання Virtual DOM робить React ефективним та зручним інструментом для розробки веб-додатків.</Answer>

          <Title>2.Яка різниця між virtual DOM та shadow DOM?</Title>     
          <Answer>Virtual DOM та Shadow DOM - це дві різні концепції, які використовуються веб-розробкою для поліпшення управління та ізоляції DOM-структур. Однак вони розроблені для різних цілей і використовуються в різних сценаріях.

Virtual DOM:

Ціль: Оптимізація оновлення та відображення DOM для покращення продуктивності.
Що це:
Virtual DOM - це механізм оптимізації роботи з реальним DOM в бібліотеках та фреймворках, таких як React. Він полягає в створенні в пам'яті віртуального представлення DOM та порівнянні його з реальним DOM для ефективного оновлення інтерфейсу.
Застосування:
Оптимізація взаємодії з реальним DOM, зменшення кількості операцій з ним, полегшення оновлення стану та відображення.
Shadow DOM:

Ціль: Забезпечення ізоляції та управління структурою DOM для створення компонентів, які ізольовані від зовнішнього коду.
Що це:
Shadow DOM - це технологія, яка дозволяє ізолювати та приховувати внутрішню структуру компонентів від зовнішнього коду. Кожен Shadow DOM володіє своїм власним замкнутим скоупом стилів і DOM-елементів.
Застосування:
Створення ізольованих компонентів, які можуть містити свою внутрішню структуру та стилі, незалежно від зовнішнього коду. Часто використовується веб-компонентами.
Важливо відзначити, що ці дві технології можуть використовуватися разом. Наприклад, бібліотека React може використовувати Virtual DOM для оптимізації відображення змін, а веб-компоненти, створені з використанням Shadow DOM, можуть забезпечувати ізоляцію та структурну інкапсуляцію.</Answer>
    
          <Title>3.Яка різниця між state та props?</Title>
          <Answer>state та props - це два основних концепти в React, які використовуються для управління даними та передачі інформації між компонентами. Однак їх призначення та способи використання відзначаються.

State:

Призначення:
state використовується для управління внутрішнім станом компонента. Це дані, які можуть змінюватися протягом життєвого циклу компонента.
Ініціалізація:
state ініціалізується у конструкторі компонента або за допомогою нового API useState у функціональних компонентах.
Зміна стану:
Для зміни state використовують метод setState(), який після встановлення нового стану переоновлює компонент та викликає його метод render().
Локальний для компонента:
state є локальним для компонента, і не може передаватися вниз по ієрархії компонентів без використання props.
Props:

Призначення:
props (властивості) використовуються для передачі даних в компонент ззовні. Вони вважаються "тим, що передається" компоненту.
Ініціалізація:
props передаються компоненту як атрибути в JSX або вказуються при виклику компонента внутрішньої частини іншого компонента.
Незмінність:
props є незмінними (immutable). Компонент не може змінювати свої власні props.
Глобальний для дерева компонентів:
props можна передавати вниз по дереву компонентів, дозволяючи даним потрапляти в дочірні компоненти.
Підсумовуючи, state використовується для управління внутрішнім станом компонента, тоді як props використовується для передачі даних в компоненти та є незмінними у своїй природі. Обидва концепти є фундаментальними для розробки на React і грають ключову роль в створенні динамічних та переиспользуемых компонентів.</Answer>
           <Title>4.Яка різниця між класовим та функціональним компонентом?</Title>
          <Answer>Стан (State):

Класові компоненти:
Мають можливість використовувати локальний стан (local state) і методи життєвого циклу.
Функціональні компоненти:
Зазвичай використовуються без власного стану. З React 16.8 і введенням хуків (наприклад, useState), функціональні компоненти можуть управляти станом та використовувати інші функціональності класових компонентів.
Життєвий цикл (Lifecycle):

Класові компоненти:
Мають повний набір методів життєвого циклу, таких як componentDidMount, componentDidUpdate, і т.д.
Функціональні компоненти:
Використовують хуки для роботи з життєвим циклом, таких як useEffect для виконання певних дій після монтажу компонента або після кожного оновлення.
Читання та передача пропсів (Props):

Класові компоненти:
Користуються this.props для отримання значень пропсів.
Функціональні компоненти:
Отримують пропси безпосередньо як параметри функції.
Розширення функціональності:

Класові компоненти:
Мають можливість використовувати більше функціональності, такої як стан, методи життєвого циклу і контекст.
Функціональні компоненти:
Зазвичай є більш простими і експресивними. З хуками, такими як useState і useEffect, вони також отримали багато функціональності, яку раніше надавали тільки класові компоненти.</Answer>
           <Title>5.Які методи життєвого циклу є в React?</Title>
          <Answer>В React існує низка методів життєвого циклу для класових компонентів, які дозволяють вам виконувати різні дії на різних етапах життєвого циклу компонента. Ось основні методи життєвого циклу в React:

Mounting (Монтаж):

constructor(): Викликається при створенні екземпляру компонента.
static getDerivedStateFromProps(): Викликається перед рендерингом і при кожному оновленні. Використовується для оновлення стану на основі нових властивостей.
render(): Відображає компонент. Це обов'язковий метод.
componentDidMount(): Викликається після рендерингу компонента. Використовується для виконання дій після того, як компонент був доданий до DOM.
Updating (Оновлення):

static getDerivedStateFromProps(): Знову викликається при оновленні. Використовується для оновлення стану на основі нових властивостей.
shouldComponentUpdate(): Викликається перед рендерингом при оновленні. Визначає, чи потрібно виконувати оновлення компонента.
render(): Повторно відображає компонент.
getSnapshotBeforeUpdate(): Викликається перед тим, як оновлений вміст був відображений на екрані. Використовується для отримання даних перед оновленням.
componentDidUpdate(): Викликається після завершення оновлення. Використовується для виконання дій після оновлення компонента.
Unmounting (Видалення):

componentWillUnmount(): Викликається перед тим, як компонент буде видалений з DOM. Використовується для виконання необхідних очисних операцій.
Error Handling (Обробка Помилок):

static getDerivedStateFromError(): Викликається при виникненні помилки при рендерингу дочірнього компонента. Використовується для оновлення стану на основі помилки.
componentDidCatch(): Викликається після того, як виникла помилка при рендерингу дочірнього компонента. Використовується для логування помилок.
Ці методи дозволяють вам керувати поведінкою компонентів на різних етапах їхнього життєвого циклу. У реактивному програмуванні також існують хуки, такі як useEffect в функціональних компонентах, які забезпечують подібні можливості для роботи з життєвим циклом.</Answer>
           <Title>6.Як оновити state у класовому компоненті?</Title>
        <Answer>Оновлення стану у класовому компоненті в React виконується за допомогою методу setState().
          Цей метод приймає аргумент у вигляді об'єкта, який містить новий стан, або приймає функцію, яка отримує поточний стан і властивості та повертає новий стан.
Важливо вказати, що setState() може бути асинхронним, і React може групувати кілька викликів setState() для оптимізації продуктивності. Якщо новий стан залежить від поточного стану, краще використовувати функцію у setState(), оскільки вона гарантує правильне оновлення стану.

        </Answer>
           <Title>7.Чому setState асинхронна функція?</Title>
          <Answer>setState у React є асинхронною функцією з кількома причинами:

Оптимізація продуктивності:

React може групувати декілька викликів setState та обробляти їх разом, щоб уникнути непотрібних оновлень і оптимізувати продуктивність. Це може бути особливо корисно при викликах setState в одному циклі життєвого циклу чи при обробці подій.
Відновлення поточного стану:

React може визначити, що вказані зміни стану базуються на поточному стані компонента. Якщо викликати setState синхронно, це може привести до проблем, оскільки React може ще не оновити внутрішній стан компонента.
Життєвий цикл та рендеринг:

Асинхронний підхід setState дозволяє React планувати оновлення стану таким чином, щоб вони відбувалися відповідно до життєвого циклу та рендерингу. Це допомагає уникнути непотрібних перерендерів та може підвищити продуктивність додатка.
Основна концепція полягає в тому, що виклик setState не негайно міняє стан, а планує його оновлення. Це забезпечує більш прогнозоване та ефективне оновлення стану у React-додатках.</Answer>
           <Title>8.Що потрібно зробити, щоб компонент оновився?</Title>
          <Answer>У React, оновлення компоненту може відбутися автоматично, коли стан (state) або властивості (props) змінюються. Однак є кілька способів вручну спричинити оновлення компонента.

setState для оновлення стану:
Викликайте метод setState для зміни стану компонента. Це автоматично спричинить перерендеринг компонента. 
У React, оновлення компоненту може відбутися автоматично, коли стан (state) або властивості (props) змінюються. Однак є кілька способів вручну спричинити оновлення компонента.

setState для оновлення стану:
Викликайте метод setState для зміни стану компонента. Це автоматично спричинить перерендеринг компонента.


forceUpdate метод:
          Виклик методу forceUpdate також може вручну примусити компонент оновити свій стан та відобразити зміни. Звертайте увагу, що використання
          forceUpdate вважається не найкращою практикою і варто уникати його, якщо це не абсолютно необхідно.
          Використання ключа (key) при відображенні:
          Зміна ключа компонента при його відображенні може призвести до його перерендерингу.
          Хуки в функціональних компонентах:
У функціональних компонентах використання хуків, таких як useState та useEffect, дозволяє автоматично керувати оновленням компонента при зміні стану або властивостей.
        </Answer>
        
        <Title>9.Як запобігти зайвому оновленню компонента?</Title>
        <Answer>Використовуйте shouldComponentUpdate у класових компонентах:
Ви можете використовувати метод shouldComponentUpdate для визначення, чи потрібно виконувати перерендеринг компонента при зміні стану чи властивостей. Повернення false зупиняє оновлення.Використовуйте PureComponent:
PureComponent є класом, який вже має вбудований метод shouldComponentUpdate, який автоматично порівнює всі властивості та стан. Використовуйте PureComponent замість Component, якщо ваш компонент залежить тільки від властивостей та стану.Використовуйте React.memo для функціональних компонентів:
Використовуйте React.memo для автоматичного порівняння властивостей функціонального компонента та уникнення зайвих рендерів.Передавайте функції як властивості замість вбудованих методів:
При передачі функцій як властивостей компоненту, уникайте визначення їх у тілі класу. Кожен раз, коли ви передаєте функцію як властивість, створюється нова функція, що може спричинити зайві оновлення. Замість цього використовуйте стрілкові функції або методи, визначені за межами рендерингу.
        
        
        </Answer>
           <Title>10.Яка особливість PureComponent?
</Title>
          <Answer>PureComponent є класом у React, який представляє собою спеціальний випадок звичайного класового компонента (Component). Основна особливість PureComponent полягає в автоматичному виклику методу shouldComponentUpdate для порівняння нових та поточних властивостей та стану. Це дозволяє уникнути зайвого оновлення компонента, якщо властивості та стан не змінились.

Основні риси та особливості PureComponent:

Автоматичне порівняння властивостей та стану:

PureComponent автоматично викликає shouldComponentUpdate і порівнює всі властивості (props) та стан (state) з попередніми значеннями. Якщо вони рівні, то оновлення компонента не відбудеться.
Автоматична оптимізація для простих випадків:

Якщо ваш компонент не залежить від внутрішнього стану, а лише від властивостей, PureComponent може автоматично оптимізувати оновлення, щоб уникнути зайвих рендерів.
Не викликає render при непотрібних оновленнях:

Якщо shouldComponentUpdate повертає false, метод render не буде викликаний, що зменшить навантаження на DOM та покращить продуктивність.
Рекомендації щодо використання:

Використовуйте PureComponent тільки тоді, коли ви впевнені, що порівнювані властивості та стан можна швидко порівняти (наприклад, примітивні значення або прості об'єкти/масиви).
Не викликає shouldComponentUpdate для глибоких порівнянь:

Якщо властивість чи стан містять вкладені об'єкти або масиви, PureComponent не проводить глибоке порівняння. Таким чином, якщо ви змінюєте вкладений об'єкт чи масив, оновлення може відбутись, навіть якщо вони мають однакову структуру.
Щоб використовувати PureComponent, ваш клас повинен успадковуватися від PureComponent замість звичайного Component:</Answer>
           <Title>11.Для чого потрібні key?
</Title>
          <Answer>key - це атрибут, який використовується в React при рендері списків елементів. Кожен елемент в списку повинен мати унікальний key. Основна причина використання ключів - це покращення ефективності та ефективності вирішення проблем, пов'язаних із перерендерюванням списків.

Основні причини використання ключів в React:

Ефективне перерендерювання списків:

При зміні порядку, кількості або додаванні/видаленні елементів в списку React використовує ключі для ефективного перерендерювання тільки тих елементів, які зазнали змін. Це дозволяє уникнути повного перерендерювання всього списку, що поліпшує продуктивність.
Унікальність елементів:

Ключі допомагають React відслідковувати ідентичність кожного елемента в списку. Це важливо для правильного визначення змін та вирішення проблем із збереженням стану компонентів.
Допомога зі збереженням стану компонентів:

Якщо ви маєте компоненти в списку, які зберігають свій власний стан, ключі допомагають React правильно ідентифікувати ці компоненти при перерендерюванні і зберегти їх стан.</Answer>
           <Title>12.Для чого потрібний компонент Fragment?
</Title>
          <Answer>Fragment - це спеціальний компонент в React, який дозволяє групувати дочірні елементи без створення зайвого DOM-елементу. В React, компонент Fragment використовується, коли вам потрібно повернути більше одного елемента з компонента, і ви не хочете, щоб ці елементи об'єднувалися в обгортку DOM.

Основні причини використання Fragment:

Уникнення зайвого DOM-елемента:

При поверненні декількох елементів без використання Fragment, вони автоматично обгортаються в реальний DOM-елемент (зазвичай div), навіть якщо вам це не потрібно. Використання Fragment дозволяє уникнути створення зайвого DOM-елемента, що може бути важливим для стилізації та структури коду.
Повернення декількох елементів без обгортки:

Fragment дозволяє вам повертати декілька елементів без необхідності обгортки їх в зайвий контейнер. Це дуже зручно, коли ви хочете повернути список елементів чи іншу групу елементів.</Answer>
           <Title>13.Для чого потрібні портали?</Title>
          <Answer>
Портали (Portals) в React дозволяють вам рендерити дочірні компоненти в DOM-елемент, який знаходиться за межами структури компонента, що рендерить їх. Основні причини використання порталів включають:

Рендеринг в інший DOM-контейнер:

За допомогою порталів ви можете рендерити компоненти в будь-який інший DOM-контейнер, який існує в вашій веб-сторінці. Це дозволяє вам створювати компоненти, які виводяться за межами основного дерева DOM вашого додатка.
Рендеринг в контейнери поверх інших елементів:

Портали дозволяють вам вставляти компоненти поверх інших елементів в DOM. Наприклад, ви можете створити модальне вікно, яке буде виводитися поверх усього іншого в DOM-структурі.
Рендеринг в загальності несподівані місця:

За допомогою порталів ви можете рендерити компоненти в місця, які ви не очікували. Це може бути корисним для створення розділених ділянок UI або рендерингу компонентів у визначених областях сторінки.
Уникнення проблем з контекстом та стилями:

Використання порталів дозволяє уникнути проблем з контекстом та стилями, оскільки рендеринг в інший контейнер не впливає на контекст і стилі основного компонента.</Answer>
           <Title>14.Що таке refs?
</Title>
          <Answer>ref в React - це спеціальний атрибут, який дозволяє вам отримати прямий доступ до DOM-елемента чи екземпляра компонента в коді React. Використання ref може бути корисним в різних випадках, таких як управління фокусом, анімації, імперативна маніпуляція DOM та інше.

Є два способи використання ref в React:

Створення ref за допомогою React.createRef():

Використовується в класових компонентах. Callback-функція для ref:

Використовується в функціональних компонентах або коли ви працюєте з createRef() в функціональних компонентах.Основні випадки використання ref:

Отримання прямого доступу до DOM-елемента: Ви можете використовувати ref для отримання прямого доступу до DOM-елемента та виконання імперативних операцій, таких як фокусування чи вибір тексту.

Взаємодія з компонентами:

Коли вам потрібно взаємодіяти з методами компонентів, використовуючи класові компоненти. Наприклад, виклик методів певного компонента після виконання певних умов або подій.
Використання в бібліотеках для імперативного контролю:

Ви можете використовувати ref в бібліотеках або пакетах, які вимагають імперативного контролю над елементами.
Однак, використання ref повинно бути обмеженим, і в більшості випадків краще використовувати управління станом та подіями для взаємодії з компонентами в React.</Answer>
           <Title>15.Що таке context?
</Title>
          <Answer>В React, context - це механізм, який дозволяє передавати дані через дерево компонентів без явного передання пропсів через кожен рівень компонентів. Використання context зручне у випадках, коли багато компонентів потребують однакових даних, таких як тема оформлення, аутентифікація користувача або інші глобальні налаштування.

context складається з двох частин: провайдера (Context.Provider) та споживачів (Context.Consumer або використання useContext хука в функціональних компонентах).

Основні поняття, пов'язані з context:

Створення контексту:

Спершу необхідно створити контекст за допомогою функції React.createContext().Постачання значень (Provider):

Використовуйте MyContext.Provider для обгортання частини дерева компонентів, яка повинна мати доступ до значень context.Споживання значень (Consumer або useContext):

Використовуйте MyContext.Consumer або useContext(MyContext) для отримання значень context в дочірніх компонентах. Або використання useContext хука в функціональних компонентах.context дозволяє передавати дані глибоко вниз по дереву компонентів без необхідності передачі пропсів через кожен рівень компонентів. Однак слід використовувати його обережно і уникати зловживання, оскільки це може зробити код менш зрозумілим і важко підтримуваним. В більшості випадків краще використовувати передачу пропсів або стану.</Answer>

           <Title>16.Для чого потрібні render props?
</Title>
          <Answer></Answer>
           <Title>17.Що таке HOCs?
</Title>
          <Answer></Answer>
           <Title>18.Як реалізувати компонент запобіжника (Error Boundary)?</Title>
          <Answer>
</Answer>
           <Title>19.Які можливості надають хуки?</Title>
          <Answer></Answer>
           <Title>20.Які правила використання хуків?
</Title>
        <Answer></Answer>
         <Title>21.Для чого потрібний useEffect?
</Title>
        <Answer></Answer>
         <Title>22.Чим відрізняється useEffect від useLayoutEffect?
</Title>
        <Answer></Answer>
         <Title>23.Що таке лінива ініціалізація стану в useState та useReducer?
</Title>
        <Answer></Answer>
         <Title>24.Чим useRef відрізняється від createRef?
</Title>
        <Answer></Answer>
         <Title>25.Для чого потрібні useMemo та useCallback?
</Title>
        <Answer></Answer>
         <Title>26.Для чого потрібний redux?
</Title>
        <Answer></Answer>
         <Title>27.Поясніть redux data flow
</Title>
        <Answer>28.Що таке redux middleware?
</Answer>
         <Title></Title>
        <Answer>29.Де потрібно робити side effects в redux?</Answer>
         <Title>30.Що таке next() функція в redux middleware?
</Title>
        <Answer></Answer>
         <Title>31.Для чого потрібні redux селектори?
</Title>
        <Answer></Answer>
         <Title>32.Чим відрізняється action від action creator?
</Title>
        <Answer></Answer>
         <Title></Title>
          <Answer></Answer>


     </Section>
      </div>
  );
};